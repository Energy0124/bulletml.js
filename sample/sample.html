<html>
<head>
</head>
<body style="margin:0">
<script src="../target/bulletml.min.js"></script>
<script>
var CANVAS_WIDTH = 200;
var CANVAS_HEIGHT = 250;

var game;
var player;
var enemies = [];
var score = 0;

// 弾幕パターン

var $ = bulletml.dsl;
var danmaku0 = new bulletml.Root({
    top: $.action([
        $.repeat(999, [
            $.repeat(30, [
                $.fire($.direction(12, "sequence"), $.speed(5), $.bullet($.actionRef("b"))),
                $.repeat(9-1, [
                    $.fire($.direction(360/9, "sequence"), $.speed(5), $.bullet($.actionRef("b"))),
                ]),
                $.wait(2),
            ]),
            $.wait(30),
            $.repeat(30, [
                $.fire($.direction(-12, "sequence"), $.speed(5), $.bullet($.actionRef("b"), {color:"hsl(220, 60%, 80%)"})),
                $.repeat(9-1, [
                    $.fire($.direction(360/9, "sequence"), $.speed(5), $.bullet($.actionRef("b"), {color:"hsl(220, 60%, 80%)"})),
                ]),
                $.wait(2),
            ]),
            $.wait(30),
        ]),
    ]),
    b: $.action([
        $.changeSpeed($.speed(1), 30),
        $.wait(30),
        $.changeDirection($.direction(0, "aim"), 60),
        $.changeSpeed($.speed(3), 30),
        $.wait(30),
        $.vanish(),
        $.fire($.speed(2), $.bullet({color:"hsl(50, 60%, 80%)"}))
    ]),
});

// メイン処理

window.onload = function() {
    game = new Game();

    // 自機
    player = new Player();
    player.x = CANVAS_WIDTH * 0.5;
    player.y = CANVAS_HEIGHT * 0.9;
    player.addTo(game);

    // 弾幕共通設定
    var danmakuConfig = {
        
        // 「自機狙い弾」が狙う対象
        target: player,

        // 新規に弾が発生した時に呼び出される関数
        createNewBullet: function(runner, spec) {
            // runnerは弾の動作を司るオブジェクト

            var bullet = new Bullet(spec).addTo(game);

            // 弾の消滅時に呼び出される
            runner.onVanish = function() {
                bullet.remove();
            };

            bullet.update = function() {

                // runnerのupdateを毎フレームで呼び出すと、transformの位置が変化する
                runner.update();

                // runnerからそのフレームで更新された位置を取り出し、bulletに反映する
                this.x = runner.x;
                this.y = runner.y;

                this.hitTest();
            };
        }

    };

    var enemy = new Hex(40, 30, 15, "hsl(270, 60%, 80%)");
    enemy.x = CANVAS_WIDTH * 0.5;
    enemy.y = CANVAS_HEIGHT * 0.1;
    enemy.addTo(game);

    // 弾幕ランナー
    enemy.danmakuRunner = danmaku0.createRunner(enemy.x, enemy.y, danmakuConfig);

    enemy.update = function() {
        // 弾幕ランナーのupdateメソッドを毎フレーム呼び出す
        this.danmakuRunner.update();
    };

    game.start();
};

// ゲームエンジン系

/** ゲームクラス */
var Game = function() {
    var canvas = document.createElement("canvas");
    document.body.appendChild(canvas);
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;
    canvas.fitWindow();

    this.context = canvas.getContext("2d");
    this.context.textAlign = "right";
    this.context.textBaseline = "top";

    this.keyboard = new Keyboard();

    this.frame = 0;

    this.gameObjects = [];
};
Game.prototype.start = function() {
    var renderFrame = function() {
        this.context.fillStyle = "black";
        this.context.globalCompositeOperation = "source-over";
        this.context.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        this.context.globalCompositeOperation = "lighter";
        var copied = [].concat(this.gameObjects);
        for (var i = 0, end = copied.length; i < end; i++) {
            copied[i].update(this.frame);
            copied[i].draw(this.context);
        }

        this.context.fillStyle = "white";
        this.context.fillText(score, CANVAS_WIDTH*0.99, CANVAS_HEIGHT*0.01);

        this.frame += 1;
        requestAnimationFrame(renderFrame);
    }.bind(this);
    renderFrame();
};
Game.prototype.addChild = function(obj) {
    obj.parent = this;
    this.gameObjects.push(obj);
};
Game.prototype.removeChild = function(obj) {
    obj.parent = null;
    this.gameObjects.erase(obj);
};

/** 六角形クラス */
var Hex = function(w, h, radius, color) {
    this.w = w;
    this.h = h;
    this.radius = radius;
    this.x = 0;
    this.y = 0;
    this.rot = 0;
    this.color = color || "hsl(0, 60%, 80%)";

    this.canvas = document.createElement("canvas");
    this.canvas.width = w*2;
    this.canvas.height = h*2;

    var context = this.canvas.getContext("2d");
    context.globalCompositeOperation = "lighter";
    context.fillStyle = this.color;
    context.translate(w, h);
    context.globalAlpha = 1.0;
    context.fillHex(this.w, this.h);

    this.parent = null;
};
Hex.prototype = {
    constructor: Hex,
    update: function() {},
    draw: function(context) {
        context.fillStyle = this.color;
        context.save();
        context.translate(this.x, this.y);
        context.rotate(this.rot);
        context.drawImage(this.canvas, -this.canvas.width*.5, -this.canvas.height*.5);
        context.restore();
    },
    hit: function(another) {
        return (this.x - another.x)*(this.x - another.x) + (this.y - another.y)*(this.y - another.y) < (this.radius+another.radius)*(this.radius+another.radius);
    },
    addTo: function(parent) {
        parent.addChild(this);
        return this;
    },
    remove: function() {
        if (this.parent) this.parent.removeChild(this);
        return this;
    }
};

/** 敵弾クラス */
var Bullet = function(spec) {
    Hex.call(this, 8, 8, 2, spec.color);
};
Bullet.prototype = Object.create(Hex.prototype);
Bullet.prototype.hitTest = function() {
    if (this.x < 0 || CANVAS_WIDTH < this.x || this.y < 0 || CANVAS_HEIGHT < this.y) {
        this.remove();
        return;
    }

    if (this.hit(player)) {
        console.log("hit!!");
        this.remove();
        return;
    }
};

/** 自機クラス */
var Player = function() {
    Hex.call(this, 10, 10, 5, "hsl(120, 60%, 80%)");

    this.speed = 1.5;
};
Player.prototype = Object.create(Hex.prototype);
Player.prototype.shot = function(x, y, theta) {
    new PlayerBullet(this.x + x, this.y + y, theta).addTo(game);
};
Player.prototype.update = function(frame) {
    var s = game.keyboard.c ? this.speed : this.speed * 2;
    if (game.keyboard.left) this.x -= s;
    else if (game.keyboard.right) this.x += s;
    if (game.keyboard.up) this.y -= s;
    else if (game.keyboard.down) this.y += s;

    this.x = Math.max(0, Math.min(this.x, CANVAS_WIDTH));
    this.y = Math.max(0, Math.min(this.y, CANVAS_HEIGHT));

    if (game.keyboard.z && frame%5 === 0) {
        this.shot(-6, +4, Math.PI*1.5 + -0.2);
        this.shot(-4,  0, Math.PI*1.5 + -0.1);
        this.shot(-2, -4, Math.PI*1.5 + -0.0);
        this.shot(+2, -4, Math.PI*1.5 + +0.0);
        this.shot(+4,  0, Math.PI*1.5 + +0.1);
        this.shot(+6, +4, Math.PI*1.5 + +0.2);
    }
};

/** 自弾クラス */
var PlayerBullet = function(x, y, theta) {
    Hex.call(this, 3, 12, 2, "hsl(110, 60%, 80%)");

    this.x = x;
    this.y = y;
    this.bx = this.by = 0;
    this.dx = Math.cos(theta) * 5;
    this.dy = Math.sin(theta) * 5;
};
PlayerBullet.prototype = Object.create(Hex.prototype);
PlayerBullet.prototype.update = function() {
    this.bx = this.x;
    this.by = this.y;
    this.x += this.dx;
    this.y += this.dy;
    this.rot = Math.atan2(this.y-this.by, this.x-this.bx)+Math.PI*.5;
    if (this.x < 0 || CANVAS_WIDTH < this.x || this.y < 0 || CANVAS_HEIGHT < this.y) {
        this.remove();
        return;
    }
};

/** キーボードクラス */
var Keyboard = function() {
    this.up = false;
    this.down = false;
    this.left = false;
    this.right = false;
    this.c = false;
    this.z = false;
    this.x = false;
    this.space = false;

    document.addEventListener("keydown", function(e) {
        switch (e.keyCode) {
            case 18: this.space = true; break;
            case 37: this.left = true; break;
            case 38: this.up = true; break;
            case 39: this.right = true; break;
            case 40: this.down = true; break;
            case 67: this.c = true; break;
            case 88: this.x = true; break;
            case 90: this.z = true; break;
        }
    }.bind(this), false);
    document.addEventListener("keyup", function(e) {
        switch (e.keyCode) {
            case 18: this.space = false; break;
            case 37: this.left = false; break;
            case 38: this.up = false; break;
            case 39: this.right = false; break;
            case 40: this.down = false; break;
            case 67: this.c = false; break;
            case 88: this.x = false; break;
            case 90: this.z = false; break;
        }
    }.bind(this), false);
};

// ヘルパー系

Array.prototype.erase = function(obj) {
    var idx = this.indexOf(obj);
    if (idx !== -1) this.splice(idx, 1);
};
CanvasRenderingContext2D.prototype.fillHex = function(w, h) {
    this.beginPath();
    this.moveTo(Math.sin(Math.PI/3 * 0)*w*.5, Math.cos(Math.PI/3 * 0)*h*.5);
    for (var i = 1; i < 6; i++) {
        this.lineTo(Math.sin(Math.PI/3 * i)*w*.5, Math.cos(Math.PI/3 * i)*h*.5);
    }
    this.closePath();
    this.fill();
};
HTMLCanvasElement.prototype.fitWindow = function() {
    var resize = function() {
        var rateWidth = this.width/window.innerWidth;
        var rateHeight= this.height/window.innerHeight;
        var rate = this.height/this.width;
        if (rateWidth > rateHeight) {
            this.style.width  = innerWidth+"px";
            this.style.height = innerWidth*rate+"px";
        } else {
            this.style.width  = innerHeight/rate+"px";
            this.style.height = innerHeight+"px";
        }
    }.bind(this);
    window.addEventListener("resize", resize, false);
    resize();
};
</script>
</body>
</html>